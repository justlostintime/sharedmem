' Gambas class file

'Author Westwood JustLostintime
'Released Under:
'  GNU GENERAL Public LICENSE
'  Version 3, 29 June 2007
'  See project license file.
Export
'Fast Unsafe
'Extern memset(dest As Pointer, Val As Integer, len As Integer) As Pointer In "libc:6"
Extern strncpy(dest As Pointer, src As String, len As Integer) As Pointer In "libc:6" ' defined as string to force gambas to copy len 0 and return string type
'Extern strcpy(dest As Pointer, src As Pointer) As String In "libc:6"
'Extern strlen(src As Pointer) As Integer In "libc:6"
'Extern memcpy(dest As Pointer, src As Pointer, Len As Integer) As Integer In "libc:6"
'Extern smemcpy(dest As Pointer, src As String, Len As Integer) As Integer In "libc:6" Exec "memcpy"
'Extern memset(dest As Pointer, Value As Integer, Sizet As Integer) As Pointer In "libc:6"
Extern rWrite(handle As Integer, buf As Pointer, cnt As Integer) As Integer In "libc:6" Exec "write"
Extern rRead(handel As Integer, buf As Pointer, cnt As Integer) As Integer In "libc:6" Exec "read"
'Extern rClose(Handle As Integer) As Integer In "libc:6" Exec "close"

Property LastWriteLength As Integer Use $LastWriteLength = 0    '' The length of the last write
Property RootAddress As Pointer Use $RootAddress = CPointer(0)  '' The rootAddress of the actual memory
Property MemoryLength As Long Use $MemoryLength = -1            '' The length of the memory pool if originally provided
Property MemoryBlockSize As Long Use $MemoryBlockSize = -1      '' Length of each block to allocate when out of space

'' When this is set mem assumes its using real pointers not offset pointers, pointers must point to real data
'' Indirection to objects and strings will not be used , just assumes its real pointers to data
'' Root address should be set to zero if using actual memory or offset if still want to use the offset in shared memory
'' Pointers need to point to the data portion of allocated buffers
Property Read RealPointers As Boolean Use $RealPointers = False

'' This sets the usage style of the object
'' first parameter should set the base of the shared memory area or 0 for Realmemory access
'' Sets if this instance is for real memory, not base offset calculation
Public Sub _new(Optional BaseAddress As Pointer = 0, UsingRealMemoryAddress As Boolean = False, MemLength As Long = -1, MemBlockSize As Long = -1)

  $RootAddress = BaseAddress
  $RealPointers = UsingRealMemoryAddress
  $MemoryLength = MemLength
  $MemoryBlockSize = MemBlockSize

End


'' return the actual storage required for any data type
'' objects must have a _write public function
Static Public Sub _SizeOf(data As Variant) As Integer

  Dim rdType As Integer = TypeOf(Data)
  Dim rdLen As Integer = 1

  Select Case rdType
    Case gb.String
      rdLen += data.len + 1   ' will record data length and terminator zero

    Case gb.Object
      rdLen += ObjectSizeOf(data)

    Case gb.Class
      Error.Raise("_Sizeof(): Class type not supported")
      rdLen = 0

    Default
      rdLen += SizeOf(rdType)  ' will record data type

  End Select

  Return rdLen

End

'' Used the Objects _write function to get the size of the object
Static Private Sub ObjectSizeOf(data As Variant) As Integer

  Dim mFile As File
  Dim rdLen As Integer = 0

  mFile = Open Null For Write
  Try Write #mfile, data As Object
  If Error Then
    Error.Raise("Unable to write object to memory," & Error.text)
  Endif

  rdLen += Seek(mFile)
  Close mFile

  Return rdLen

End

Public Sub SetType(Mempointer As Pointer, rdType As Integer)

  Byte@($RootAddress + MemPointer) = rdType

End

'' Object entry point when used as array in user program
''  Data - data as any data type
''  MemPointer - Actual memory address to store the value
''  rdType - override the datatype of the passed in variant
''  notype - the memory location does not contain a memory variable type definition
''  if fast value is 2 4 8 then the storage is there and created already
Public Sub _put(Data As Variant, MemPointer As Pointer, Optional rdType As Integer = -1, notype As Boolean = False)

  Dim mfile As File

  If mempointer < 0 Then
    Print "Bad pointer : "; mempointer
    Stop
  Endif

  Dim BasePtr As Pointer = $RootAddress + MemPointer

  If Not notype Then
    If rdType = -1 Then                                    ' if this is -1 we assume this is a new or default call
      rdType = TypeOf(data)
      Byte@(BasePtr) = rdType
    Endif
    Inc mempointer
    Inc BasePtr
  Endif

  $LastWriteLength = SizeOf(rdType)
  'Error "_put type = "; rdtype;; SharedMem.DataTypes[rdtype]
  Select Case rdType

    Case gb.Long
      Long@(BasePtr) = data

    Case gb.integer
      Integer@(BasePtr) = data

    Case gb.pointer
      Pointer@(BasePtr) = data

    Case gb.short
      Short@(BasePtr) = data

    Case gb.float
      Float@(BasePtr) = data

    Case gb.boolean
      Boolean@(BasePtr) = data

    Case gb.byte
      Byte@(BasePtr) = data

    Case gb.date
      Date@(BasePtr) = data

    Case gb.Single
      Single@(BasePtr) = data

    Case gb.String
      'Dim iString As Byte[] = byte[].fromString(data)

      If Not $RealPointers Then
        MemPointer = Me[MemPointer, gb.Pointer, True]                            ' Pointer@(RootAddress + MemPointer)
        memPointer += $RootAddress + SharedMem.DataOffset + 1
      Endif

      ' Error "String Pointer = $"; Hex(memPointer);; "Length = "; iString.count + 1
      strncpy(Mempointer, data, data.len)
      ' If istring.count = 0 Then
      '   Byte@(Mempointer) = 0 ' empty string then
      ' Else
      '   Dim t As Pointer = mempointer
      '   For it As Integer = 0 To iString.max
      '     Byte@(t) = iString[it]
      '     Inc t
      '   Next
      '   Byte@(t) = 0
      ' Endif

      $LastWriteLength = data.len + 1
      ' Error "LastWrite Length = "; LastWriteLength

    Case gb.object
      If Not $RealPointers Then
        MemPointer = Me[MemPointer, gb.pointer, True]                     ' Pointer@(RootAddress + MemPointer)
        MemPointer += $RootAddress + SharedMem.DataOffset + 1
      Endif
      mfile = Memory MemPointer For Write
      Write #mFile, Data As Object
      $LastWriteLength = Seek(mFile)
      Close mFile

    Case gb.Class
      Error.Raise("Class must have _write Static method To be saved but not supported")
      $LastWriteLength = 0

    Case gb.function
    Case gb.NULL

    Default
      Print #File.err, "Mem default write... eeeek DataType = "; rdType
      mfile = Memory MemPointer For Write
      Write #mFile, Data As Variant
      $LastWriteLength = Seek(mFile)
      Close mFile

  End Select


End

'' Get variable from memory
''
'' Mempointer - the location to get the daya from
'' rdType - the type of data to be read, this is an over ride for the stored data type or used when no datatype stored
'' notype - the storgae location first has no data type specified
Public Sub _get(MemPointer As Pointer, Optional rdType As Integer = -1, notype As Boolean = False) As Variant

  Dim cvVariant As Variant
  Dim mFile As File

  '' print"MEM GET request: prt="; MemPointer; " RDTYPE = "; rdType
  If Not notype Then
    If rdtype = -1 Then   ' and not notype
      rdType = Byte@($RootAddress + MemPointer)  ' get the data type
    Endif
    Inc mempointer
  End If

  Dim BasePtr As Pointer = $RootAddress + MemPointer

  'DataTypes = ["*Binary", "*Boolean", "*Byte", "*Short", "*Integer", "*Long", "*Single", "*Float", "*Date", "*String",
  '                                       "*LongDate", "*Pointer", "*Variant", "*Function", "*Class", "NULL", "*Object", "Not Array", "", "", "", "", "", ""]

  On rdType Goto DoBinary, DoBoolean, DoByte, DoShort, DoInteger, DoLong, DoSingle, DoFloat, DoDate, DoString, DoLongDate, DoPointer, DoVariant, DoFunction, DoClass, DoNull, DoObject


DoPointer:

  Return Pointer@(BasePtr)

DoInteger:
  Return Integer@(BasePtr)

DoLong:
  Return Long@(BasePtr)

DoString:
  If Not $RealPointers Then
    MemPointer = Pointer@($RootAddress + MemPointer)
    MemPointer = $RootAddress + MemPointer + SharedMem.DataOffset + 1
    Return String@(MemPointer)
  Else
    Return String@(MemPointer)
  Endif

DoObject:
DoVariant:
  Dim MyObject As Object
  If Not $RealPointers Then
    MemPointer = Pointer@($RootAddress + MemPointer)
    MemPointer += $RootAddress + SharedMem.DataOffset + 1
  Endif
  mfile = Memory MemPointer For Read
  Try MyObject = Read #mFile As Object
  If Error Then Print #File.err, "Object read failed"
  $LastWriteLength = Seek(mFile)
  Close mFile
  Return MyObject

DoClass:
  Error.Raise("Class read must implement _read static method but not supported")
  Return Null

DoBoolean:
  Return Boolean@(BasePtr)

DoShort:
  Return Short@(BasePtr)

DoByte:
  Return Byte@(BasePtr)

Dofloat:
  Return Float@(BasePtr)

DoDate:
  Return Date@(BasePtr)

DoSingle:
  Return Single@(BasePtr)

DoFunction:
DoNull:
  Return Null

DoBinary:
  Return BasePtr

DoLongDate:
  mfile = Memory BasePtr For Read
  cvVariant = Read #mfile As Variant
  Close mFile
  Return cvVariant

End

'' This function returns the address of the data portion of the memory location
'' notype will always assume binary type and return the address of binary blob at the address
'' The read type can override the normal value for the variable
Public Sub AddrData(MemPointer As Pointer, Optional rdtype As Integer = -1, notype As Boolean = False) As Pointer

  If $RealPointers Then
    Error.Raise("AddrData is not valid in realAddressMode")
    Return Null
  Endif

  If Not notype Then
    If rdtype = -1 Then ' And Not notype Then
      rdType = Byte@($RootAddress + MemPointer)  ' get the data type
    Endif
    Inc mempointer
  End If

  Select Case rdtype
    Case gb.string, gb.object, gb.Variant
      MemPointer = Pointer@($RootAddress + MemPointer)
      Mempointer += $RootAddress + SharedMem.DataOffset + 1
    Default
      mempointer += $RootAddress
  End Select

  Return mempointer

End

'' This function returns the relative addr of the data portion of the memory location
'' notype will always assume binary type and return the address of binary blob at the address
'' The read type can override the normal value for the variable

Public Sub DataOffset(MemPointer As Pointer, Optional rdtype As Integer = -1, notype As Boolean = False) As Pointer

  Dim addrptr As Pointer = AddrData(Mempointer, rdtype, notype)

  Return addrptr - $rootaddress

End

'' AddrReal returns the Real memory address of the data,
'' Most address used within this class are virtual addresses
'' within the allocated shared memory block
Public Sub AddrReal(mempointer As Pointer) As Pointer

  Return $RootAddress + Mempointer

End

'' Load data from afile into virtual memory
'' Address provided id the virtual memory offset
Public Sub ReadData(mPointer As Pointer, mFile As File, DataLength As Integer, Optional rdType As Integer = -1, noType As Boolean = False)

  rRead(mFile.handle, AddrData(mPointer, rdType, noType), DataLength)

End

'' Write a block of data from virtual memory
'' address provided is virtual i.e. the offset with the allocated
'' Shared memory block
Public Sub WriteData(mPointer As Pointer, mFile As File, DataLength As Integer, Optional rdType As Integer = -1, noType As Boolean = False)

  rWrite(mFile.handle, AddrData(mPointer, rdType, noType), datalength)

End
'' a function which may be called to dump the content of any memory area to a file
'' The default location if no name specified is the users desktop as dumpfile

Static Public Sub DumpMem(mPointer As Pointer, IntLength As Integer, Optional Filename As String = User.home & "/Desktop/dumpfile")

  Dim mFile As File

  If File.Dir(Filename) = "" Then
    filename = User.home & "/Desktop/" & filename
  Endif

  mFile = Open filename For Write Create

  rWrite(mFile.handle, mPointer, IntLength)

  Close mFile

End

'' Dump all the memory for this mem object
Public Sub DumpAllMem()

  DumpMem($RootAddress, $MemoryLength)

End

