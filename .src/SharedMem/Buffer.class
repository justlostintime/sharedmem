' Gambas class file

'Author Westwood JustLostintime
'Released Under:
'  GNU GENERAL Public LICENSE
'  Version 3, 29 June 2007
'  See project license file.

Export

'Fast Unsafe


'' Most properties are set by the creater of the buffer
Property RootAddress As Pointer Use $RootAddress = 0
Property StorageLength As Integer Use $StorageLength = 0
Property SymbolName As String Use $SymbolName = ""
Property DataType As Integer Use $DataType = gb.byte
Property CreatedByMe As Boolean Use $CreatedByMe = False
Property Parent As Object Use $Parent = Null
Property oShm As Variant Use $oShm = Null


Extern memcpy(dest As Pointer, src As Pointer, Len As Integer) As Integer In "libc:6"
Extern memcmp(CompVal1 As Pointer, CompVal2 As Pointer, NumBerOfBytes As Integer) As Integer In "libc:6"
Extern memset(dest As Pointer, Value As Integer, Sizet As Integer) As Pointer In "libc:6"

Extern rWrite(handle As Integer, buf As Pointer, cnt As Integer) As Integer In "libc:6" Exec "write"
Extern rRead(handel As Integer, buf As Pointer, cnt As Integer) As Integer In "libc:6" Exec "read"

Property SupportedDataTypes As Integer[] Use $SupportedDataTypes = [gb.byte, gb.short, gb.integer, gb.long, gb.string]
InValidTypeMessage As String = "Invalid data type, must be Byte, Short,Integer,Long,Pointer,byte Requested : &1 Assuming Byte"

'' The only creation input to this is the actual shared memory segment used
'' The rest are assigned after the creation of this buffer
Public Sub _new(Optional vshm As Variant = Null)

  $oShm = vshm

End

'' This function reads an object definition from the provided
'' open input stream, the first integer must be the length
'' of the object
Public Sub _read(mFile As File)

  Dim iLen As Integer

  iLen = Read #mFile As Integer
  If $StorageLength < iLen Then
    Error.Raise("Buffer too small size=" & Str($StorageLength) & ", Stored Object Read Size = " & Str(iLen))
  Endif

  iLen = Me.Read(mFile)

End


Public Sub _write(mFile As File)

  Write #mFile, $StorageLength As Integer
  Me.Write(mFile)

End

Public Sub Access(symbol As String, Optional rdType As Integer = gb.byte) As Pointer

  Dim MySymbol As SharedMemSymbol

  MySymbol = SharedMem._Symbol(symbol)
  If IsNull(mySymbol) Then
    Error.Raise("Symbol not found")
    Return CPointer(Null)
  Endif

  If Not $SupportedDataTypes.Exist(rdType) Then
    Error.Raise(Format(InValidTypeMessage, rdType))
    Return CPointer(Null)
  Endif

  $RootAddress = MySymbol.DataAddress + 1
  $StorageLength = MySymbol.StorageLength - SharedMem.AllocHeaderLen - 1
  $DataType = rdType
  $SymbolName = symbol
  $Parent = MySymbol

  If IsNull(MySymbol.SpecialObject) Then
    MySymbol.SpecialObject = Me
  Endif

  Return $RootAddress

End

'' Create a shared memory segment to contain this buffer
Public Sub Create(symbol As String, ilen As Integer, Optional rdType As Integer = gb.byte) As Pointer ' return the new buffer space

  If Not IsNull($rootaddress) Then
    Error.Raise("Buffer in Use")
    Return Null
  Endif

  $DataType = rdType

  If Not $SupportedDataTypes.Exist($DataType) Then
    $DataType = gb.byte
    Error.Raise(Format(InValidTypeMessage, $DataType))
    Return Null
  Endif

  ilen = ilen * SizeOf($DataType)
  $RootAddress = SharedMem.NamedAlloc(symbol, ilen, Me)
  $StorageLength = ilen
  $symbolName = symbol
  $CreatedByMe = True
  $Parent = Null

  Return $RootAddress

End

Public Sub Release() As Boolean ' release the memory

  If Not $CreatedByMe Then Return False

  SharedMem.free($SymbolName)
  $RootAddress = 0
  $SymbolName = ""
  $StorageLength = 0
  Return True

End

Public Sub Read(Optional mFile As Variant = "", start As Integer, ilength As Integer) As Pointer ' returns a pointer to the first stored byte

  Dim handle As Integer
  Dim rFile As File = Null
  Dim rLen As Integer

  If iLength = 0 Then iLength = $StorageLength

  If iLength < 1 Or start + iLength > $StorageLength Then
    Error.Raise("Buffer too small size=" & Str($StorageLength) & ", Stored Object Read Size = " & Str(iLength) & " at index of " & Str(start))
    Return 0
  Endif

  Select Case TypeOf(mFile)

    Case gb.Integer
      handle = mFile

    Case gb.string
      Dim filename As String
      If mFile = "" Then
        Filename = SharedMem.DefaultSaveLocation & $symbolName & "_Raw"
      Else
        FileName = If(File.Dir(mFile) = "", SharedMem.DefaultSaveLocation & mFile, mfile)
      Endif

      rFile = Open filename For Read
      handle = rFile.handle

    Default
      handle = mFile.handle

  End Select

  rLen = rRead(handle, $RootAddress + start, ilength)

  If Not IsNull(rfile) Then Close rFile

  Return rLen

End

Public Sub Write(Optional mFile As Variant = "", Optional start As Integer = 0, ilength As Integer = 0) As Integer ' returns number of bytes written

  Dim handle As Integer
  Dim rFile As File = Null
  Dim rLen As Integer

  If iLength = 0 Then iLength = $StorageLength

  If iLength < 1 Or start + iLength > $StorageLength Then
    Error.Raise("Attempt to copy data from outside buffer")
    Return 0
  Endif

  Select Case TypeOf(mFile)

    Case gb.Integer
      handle = mFile

    Case gb.string
      Dim filename As String
      If mFile = "" Then
        Filename = SharedMem.DefaultSaveLocation & $symbolName & "_Raw"
      Else
        FileName = mFile
      Endif

      rFile = Open filename For Write Create
      handle = rFile.handle

    Default
      handle = mFile.handle

  End Select

  rLen = rWrite(handle, $RootAddress + start, ilength)

  If Not IsNull(rfile) Then Close rFile

  Return rlen

End


Public Sub _get(index As Integer) As Variant

  If index > $Storagelength Or index < 0 Then
    Error.Raise("Index outside of buffer")
    Return 0
  Endif
  Select Case $Datatype
    Case gb.Byte
      Return Byte@($RootAddress + index)
    Case gb.Long
      Return Long@($RootAddress + index)
    Case gb.Pointer
      Return Pointer@($RootAddress + index)
    Case gb.integer
      Return Integer@($RootAddress + index)
    Case gb.String
      Return String@($RootAddress + index)
    Case gb.Binary
      Return $RootAddress + index       'just return a pointer if we are working with binary
  End Select

End

Public Sub _put(Data As Variant, index As Integer)

  Dim $LastWriteLength As Integer = 0
  Dim RdType As Integer

  Dim mempointer As Pointer = $RootAddress + index

  rdType = TypeOf(data)

  $LastWriteLength = SizeOf(rdType)
  If index < 0 Or (index + $LastWriteLength) > $StorageLength Then
    Error.Raise($SymbolName & " Size " & Str(index) & " is Out of bounds")
    Return
  Endif

  $LastWriteLength = SizeOf(rdType)

  Select Case rdType


    Case gb.Pointer, gb.integer, gb.Long, gb.byte, gb.float, gb.date, gb.Boolean, gb.Short, gb.Single
      memcpy(mempointer, VarPtr(data), $LastWriteLength)

    Case gb.String

      If index + data.len + 1 > $StorageLength Then
        Error.Raise($SymbolName & " String Refrence " & Str(index + data.len) & " size Out Of bounds")
        Return
      Endif

      memcpy(MemPointer, VarPtr(data), data.len)
      memset(MemPointer + data.len, 0, 1)

    Default
      Error.Raise($Symbolname & " Unsupported datatype " & SharedMem.DataTypes[rdType] & " for buffer copy")

  End Select

End

Public Sub CopyTo(Dest As Pointer, index As Integer, length As Integer) As Pointer ' returns the pointer to the start of the copy
  ' well this is unsafe but here we go

  If index > $StorageLength - 1 Or index + Length > $StorageLength Then
    Error.Raise("Out Of Bounds")
    Return CPointer(Null)
  Endif

  memcpy(dest, $RootAddress + index, length)
  Return dest

End

Public Sub CopyFrom(src As Pointer, index As Integer, length As Integer) As Pointer ' returns the pointer to the start of the copy

  If length < 0 Or index + length > $storageLength Then
    Error.Raise("Out Of Bounds")
    Return Null
  Endif
  memcpy($RootAddress + index, src, length)
  Return $RootAddress + index

End

Public Sub FillMem(value As Integer, Optional index As Integer, length As Integer = 0)

  If length = 0 Then length = $StorageLength - index

  If index + length > $StorageLength Then
    Error.Raise($Symbolname & " index + len out of bounds")
    Return
  Endif

  memset($RootAddress + index, value, length)

End


Public Sub Duplicate(Symbol As String) As Buffer ' returns a pointer to the new storage area

  Dim myBuff As New Buffer($oShm)

  myBuff.Create(symbol, $StorageLength)
  memcpy(myBuff(), Me(), $storageLength)
  Return mybuff

End


Public Sub Compare(src As Pointer, length As Integer, Optional offset As Integer = 0) As Integer

  If offset + length > $StorageLength Then
    Error.Raise("Out Of Bounds")
    Return Null
  Endif

  Return memcmp($RootAddress + offset, src, length)

End

Private Sub VerifyCompare(src As Variant, length As Integer, offset As Integer) As Integer

  Dim Dest As Pointer
  Dim rdType As Integer = TypeOf(src)

  If rdType = gb.object Then

    If Not (Object.Type(src) = "Buffer" Or Object.Type(src) = "Element") Then
      Error.Raise("Invalid compare object")
      Return 0
    Endif
    If length = 0 Then
      length = If(src.Len() > $StorageLength, $StorageLength, src.Len())
    Endif
    Dest = src()
  Else
    If rdType = gb.pointer Then
      dest = src
    Else
      Dest = VarPtr(src)
      If rdType = gb.string Then
        length = src.len
      Else
        length = SizeOf(rdType)
      Endif
    Endif
  Endif

  If offset + length > $StorageLength Then
    Error.Raise("Out Of Bounds")
    Return 0
  Endif

  Return memcmp($RootAddress + offset, Dest, length)

End


Public Sub Equal(src As Variant, Optional length As Integer = 0, offset As Integer = 0) As Boolean

  Return If(VerifyCompare(src, length, offset) = 0, True, False)

End

Public Sub Less(src As Variant, Optional length As Integer = 0, offset As Integer = 0) As Boolean

  Return If(VerifyCompare(src, length, offset) < 0, True, False)

End

Public Sub Greater(src As Variant, Optional length As Integer = 0, offset As Integer = 0) As Boolean

  Return If(VerifyCompare(src, length, offset) > 0, True, False)

End

Public Sub _VarLen() As Integer

  Return $StorageLength

End


Public Sub Len() As Integer

  Return $StorageLength

End


Public Sub _VarPtr() As Pointer

  Return $RootAddress

End

Public Sub _call() As Pointer

  Return $RootAddress

End

Public Sub _print()

  Dim MyStr As String = ""
  Dim MyByte As String

  Print "\nMemory listing for "; $SymbolName; " Length is "; $StorageLength; " Bytes"

  For i As Integer = 0 To $StorageLength - 1

    MyByte = Chr(Byte@($RootAddress + i))

    If i Mod 32 = 0 Then
      Print " - " & MyStr & "\n"; $RootAddress + i;;
      MyStr = ""
    Endif
    MyStr &= If(IsAlnum(MyByte) Or (mybyte = " ") Or IsPunct(mybyte), MyByte, ".")
    Print Hex$(Byte@($RootAddress + i), 2);;

  Next

  While i Mod 32 <> 0
    Inc i
    Print "   ";
  Wend

  Print " - " & MyStr & "\n"

End











Private Function SupportedDataTypes_Read() As Integer[]



End

Private Sub SupportedDataTypes_Write(Value As Integer[])



End
