' Gambas class file

'Author Westwood JustLostintime
'Released Under:
'  GNU GENERAL Public LICENSE
'  Version 3, 29 June 2007
'  See project license file.

Export

'Fast Unsafe


'' Most properties are set by the creater of the buffer
Property RootAddress As Pointer Use $RootAddress = 0                         ' Actual phisical address of the memory we are using
Property RelativeAddress As Pointer Use $RelativeAddress = 0              ' address relative to the named shared segment
Property StorageLength As Integer Use $StorageLength = 0
Property SymbolName As String Use $SymbolName = ""
Property DataType As Integer Use $DataType = gb.byte
Property CreatedByMe As Boolean Use $CreatedByMe = False
Property Parent As Object Use $Parent = Null
Property oShm As Variant Use $oShm = Null
Property Fields As Collection Use $Fields
Property Methods As Collection Use $Methods
Property BytesUsed As Integer Use $BytesUsed = 0

Extern memcpy(dest As Pointer, src As Pointer, Len As Integer) As Integer In "libc:6"
Extern memcmp(CompVal1 As Pointer, CompVal2 As Pointer, NumBerOfBytes As Integer) As Integer In "libc:6"
Extern memset(dest As Pointer, Value As Integer, Sizet As Integer) As Pointer In "libc:6"

Extern rWrite(handle As Integer, buf As Pointer, cnt As Integer) As Integer In "libc:6" Exec "write"
Extern rRead(handel As Integer, buf As Pointer, cnt As Integer) As Integer In "libc:6" Exec "read"

Property SupportedDataTypes As Integer[] Use $SupportedDataTypes = [gb.byte, gb.short, gb.integer, gb.long, gb.string]
InValidTypeMessage As String = "Invalid data type, must be Byte, Short,Integer,Long,Pointer,byte Requested : &1 Assuming Byte"


'' The only creation input to this is the actual shared memory segment used
'' The rest are assigned after the creation of this buffer
Public Sub _new(Optional vshm As Variant = Null, BufLength As Integer = 0, SymName As String = "", BufType As Integer = gb.byte)

  $oShm = vshm
  If BufLength > 0 Then
    If symname <> "" Then
      Create(SymName, BufLength, BufType)
    Else
      Error.Raise("Missing Buffer definition symbol name")
    Endif
  Endif
  $Fields = New Collection(gb.ignorecase)
  $Methods = New Collection(gb.ignorecase)

End

Public Sub {Define}(ElementName As String, ElOffset As Integer, ElLength As Integer, Optional ElType As Integer = gb.byte) As BufferFields

  Dim newField As BufferFields

  If Eloffset > $StorageLength Then
    Error.Raise("Element offset greater than buffer length")
  Endif
  If ElOffset + ElLength > $StorageLength Then
    Error.Raise("Element Offset+ Length greater  than buffer length")
  Endif
  newField = New BufferFields(ElementName, ElOffset, ElLength, ElType)
  $Fields.add(newField, ElementName)

End

Private $isProperty As Boolean = True

Public Sub _property(...) As Boolean

  $IsProperty = $Fields.exist(Param.name)

  If Not $IsProperty Then
    $Fields.Add(Null, Param.name)
    Debug "Warning Automatic creation of Buffer Field entry : ";; Param.name
  Endif

  Return $IsProperty

End

Public Sub _Unknown(...) As Variant

  Dim theField As BufferFields
  Dim RealOffset As Pointer

  If $isProperty Then
    $isProperty = False
    If $Fields.exist(Param.name) Then
      theField = $Fields[Param.Name]
      RealOffset = theField.Offset + $RelativeAddress
      If Param.Count = 0
        Return SharedMem.UserMem._get(RealOffset, theField.DataType, True, True, True)
      Else If Param.Count = 1 Then
        SharedMem.UserMem._put(Param[0], realOffset, theField.DataType, True, True, True)
      Endif
    Else
      Error.Raise("Buffer unknow Field name : " & Param.Name)
    Endif

  Else
    If $Methods.exist(Param.name) Then

    Else
      Dim newField As New BufferFields(Me, Param.name, $BytesUsed)

      If Param.count >= 2 And If Param[1] <> -1 Then    ' we got length and offset
        newField.Offset = Param[1]
      Endif

      If Param.Count >= 1 Then
        If Param.count = 1
          If TypeOf(Param[0]) = gb.string Then
            newField.length = Param[0].len + 1
            newField.DataType = gb.string
          Else
            newField.DataType = TypeOf(Param[0])
            newField.Length = SizeOf(TypeOf(Param[0]))
          Endif
        Else
          newField.Length = Param[0]
        Endif
      Endif
    Endif

    If Param.count = 3 Then                     ' we also have a data type for the field
      newField.DataType = Param[2]
      If Param[0] = -1 Then
        newField.length = SizeOf(Param[2])
      Else If SizeOf(param[2]) > NewField.Length
        Error.Raise("Buffer Field length Is Too small To contain requested datatype")
      Endif
      ' Else
      '   If TypeOf(Param[0]) = gb.string Then
      '     newField.DataType = gb.string
      '   Else
      '     newField.DataType = gb.byte
      '   Endif
    Endif

    If newField.Offset + newField.Length > $StorageLength Then
      Error.Raise("Buffer Field Definition exceeds buffer capacity")
    Endif

    If $BytesUsed < (newField.offset + newField.length) Or If Param.count = 1 Then
      $BytesUsed = newField.offset + newField.length
    Endif

    $Fields[Param.name] = newField

    'If TypeOf(Param[0]) = gb.string Then
    If Param.count = 1 Then
      RealOffset = NewField.Offset + $RelativeAddress
      SharedMem.UserMem._put(Param[0], realOffset, NewField.DataType, True, True, True)
    Endif
  Endif

End


'' This function reads an object definition from the provided
'' open input stream, the first integer must be the length
'' of the object
Public Sub _read(mFile As File)

  Dim iLen As Integer

  iLen = Read #mFile As Integer
  If $StorageLength < iLen Then
    Error.Raise("Buffer too small size=" & Str($StorageLength) & ", Stored Object Read Size = " & Str(iLen))
  Endif

  iLen = Me.Read(mFile)

End


Public Sub _write(mFile As File)

  Write #mFile, $StorageLength As Integer
  Me.Write(mFile)

End

Public Sub Access(symbol As String, Optional rdType As Integer = gb.byte) As Pointer

  Dim MySymbol As SharedMemSymbol

  MySymbol = SharedMem._Symbol(symbol)
  If IsNull(mySymbol) Then
    Error.Raise("Symbol not found")
    Return CPointer(Null)
  Endif

  If Not $SupportedDataTypes.Exist(rdType) Then
    Error.Raise(Format(InValidTypeMessage, rdType))
    Return CPointer(Null)
  Endif

  $RelativeAddress = MySymbol.DataAddress + 1
  $RootAddress = SharedMem.PhysicalAddress($RelativeAddress)
  $StorageLength = MySymbol.StorageLength - SharedMem.AllocHeaderLen - 1
  $DataType = rdType
  $SymbolName = symbol
  $Parent = MySymbol

  If IsNull(MySymbol.SpecialObject) Then
    MySymbol.SpecialObject = Me
  Endif

  Return $RootAddress

End

'' Create a shared memory segment to contain this buffer
Public Sub Create(symbol As String, ilen As Integer, Optional rdType As Integer = gb.byte) As Pointer ' return the new buffer space

  If Not IsNull($rootaddress) Then
    Error.Raise("Buffer in Use")
    Return Null
  Endif

  $DataType = rdType

  If Not $SupportedDataTypes.Exist($DataType) Then
    $DataType = gb.byte
    Error.Raise(Format(InValidTypeMessage, $DataType))
    Return Null
  Endif

  ilen = ilen * SizeOf($DataType)
  $RelativeAddress = SharedMem.NamedAlloc(symbol, ilen, Me)
  $RootAddress = SharedMem.PhysicalAddress($RelativeAddress)
  $StorageLength = ilen
  $symbolName = symbol
  $CreatedByMe = True
  $Parent = Null

  Return $RootAddress

End

Public Sub Release() As Boolean ' release the memory

  If Not $CreatedByMe Then Return False

  SharedMem.free($SymbolName)
  $RelativeAddress = 0
  $RootAddress = 0
  $SymbolName = ""
  $StorageLength = 0
  Return True

End

Public Sub Read(Optional mFile As Variant = "", start As Integer, ilength As Integer) As Pointer ' returns a pointer to the first stored byte

  Dim handle As Integer
  Dim rFile As File = Null
  Dim rLen As Integer

  If iLength = 0 Then iLength = $StorageLength

  If iLength < 1 Or start + iLength > $StorageLength Then
    Error.Raise("Buffer too small size=" & Str($StorageLength) & ", Stored Object Read Size = " & Str(iLength) & " at index of " & Str(start))
    Return 0
  Endif

  Select Case TypeOf(mFile)

    Case gb.Integer
      handle = mFile

    Case gb.string
      Dim filename As String
      If mFile = "" Then
        Filename = SharedMem.DefaultSaveLocation & $symbolName & "_Raw"
      Else
        FileName = If(File.Dir(mFile) = "", SharedMem.DefaultSaveLocation & mFile, mfile)
      Endif

      rFile = Open filename For Read
      handle = rFile.handle

    Default
      handle = mFile.handle

  End Select

  rLen = rRead(handle, $RootAddress + start, ilength)

  If Not IsNull(rfile) Then Close rFile

  Return rLen

End

Public Sub Write(Optional mFile As Variant = "", Optional start As Integer = 0, ilength As Integer = 0) As Integer ' returns number of bytes written

  Dim handle As Integer
  Dim rFile As File = Null
  Dim rLen As Integer

  If iLength = 0 Then iLength = $StorageLength

  If iLength < 1 Or start + iLength > $StorageLength Then
    Error.Raise("Attempt to copy data from outside buffer")
    Return 0
  Endif

  Select Case TypeOf(mFile)

    Case gb.Integer
      handle = mFile

    Case gb.string
      Dim filename As String
      If mFile = "" Then
        Filename = SharedMem.DefaultSaveLocation & $symbolName & "_Raw"
      Else
        FileName = mFile
      Endif

      rFile = Open filename For Write Create
      handle = rFile.handle

    Default
      handle = mFile.handle

  End Select

  rLen = rWrite(handle, $RootAddress + start, ilength)

  If Not IsNull(rfile) Then Close rFile

  Return rlen

End


Public Sub _get(index As Integer) As Variant

  If index > $Storagelength Or index < 0 Then
    Error.Raise("Index outside of buffer")
    Return 0
  Endif
  Select Case $Datatype
    Case gb.Byte
      Return Byte@($RootAddress + index)
    Case gb.Long
      Return Long@($RootAddress + index)
    Case gb.Pointer
      Return Pointer@($RootAddress + index)
    Case gb.integer
      Return Integer@($RootAddress + index)
    Case gb.String
      Dim thestring As String = String@($RootAddress + index)
      Return theString
    Case gb.Binary
      Return $RootAddress + index       'just return a pointer if we are working with binary
  End Select

End


Public Sub _put(Data As Variant, index As Integer)

  Dim $LastWriteLength As Integer = 0
  Dim RdType As Integer

  If $RelativeAddress = Null Or If $RootAddress = Null Then
    Error.Raise("UnInitialized Buffer or element ")
  Endif

  Dim mempointer As Pointer = $RootAddress + index
  Dim srcptr As Pointer = VarPtr(data)

  rdType = TypeOf(data)

  $LastWriteLength = SizeOf(rdType)
  If index < 0 Or (index + $LastWriteLength) > $StorageLength Then
    Error.Raise($SymbolName & " Size " & Str(index) & " is Out of bounds")
    Return
  Endif

  $LastWriteLength = SizeOf(rdType)

  Select Case rdType

    Case gb.Pointer, gb.integer, gb.Long, gb.byte, gb.float, gb.date, gb.Boolean, gb.Short, gb.Single
      memcpy(mempointer, srcptr, $LastWriteLength)

    Case gb.String

      If index + data.len + 1 > $StorageLength Then
        Error.Raise($SymbolName & " String Refrence " & Str(index + data.len) & " size Out Of bounds")
        Return
      Endif

      memcpy(MemPointer, srcptr, data.len)
      memset(MemPointer + data.len, 0, 1)

    Default
      Error.Raise($Symbolname & " Unsupported datatype " & SharedMem.DataTypes[rdType] & " for buffer copy")

  End Select

End

Public Sub CopyTo(Dest As Pointer, index As Integer, length As Integer) As Pointer ' returns the pointer to the start of the copy
  ' well this is unsafe but here we go

  If index > $StorageLength - 1 Or index + Length > $StorageLength Then
    Error.Raise("Out Of Bounds")
    Return CPointer(Null)
  Endif

  memcpy(dest, $RootAddress + index, length)
  Return dest

End

Public Sub CopyFrom(src As Pointer, index As Integer, length As Integer) As Pointer ' returns the pointer to the start of the copy

  If length < 0 Or index + length > $storageLength Then
    Error.Raise("Out Of Bounds")
    Return Null
  Endif
  memcpy($RootAddress + index, src, length)
  Return $RootAddress + index

End

Public Sub FillMem(value As Integer, Optional index As Integer, length As Integer = 0)

  If length = 0 Then length = $StorageLength - index

  If index + length > $StorageLength Then
    Error.Raise($Symbolname & " index + len out of bounds")
    Return
  Endif

  memset($RootAddress + index, value, length)

End


Public Sub Duplicate(Symbol As String) As Buffer ' returns a pointer to the new storage area

  Dim myBuff As New Buffer($oShm)
  Dim TheRoot, bufroot As Pointer

  TheRoot = myBuff.Create(symbol, $StorageLength)
  bufRoot = myBuff.RootAddress
  memcpy(myBuff(), Me(), $storageLength)
  myBuff.Fields = $Fields.Copy()
  mybuff.Methods = $Methods.copy()
  myBuff.BytesUsed = $BytesUsed

  myBuff.DataType = $DataType
  myBuff.CreatedByMe = $CreatedByMe
  myBuff.Parent = $Parent
  myBuff.oShm = $oShm

  Return mybuff

End


Public Sub Compare(src As Pointer, length As Integer, Optional offset As Integer = 0) As Integer

  If offset + length > $StorageLength Then
    Error.Raise("Out Of Bounds")
    Return Null
  Endif

  Return memcmp($RootAddress + offset, src, length)

End

Private Sub VerifyCompare(src As Variant, length As Integer, offset As Integer) As Integer

  Dim Dest As Pointer
  Dim rdType As Integer = TypeOf(src)

  If rdType = gb.object Then

    If Not (Object.Type(src) = "Buffer" Or Object.Type(src) = "Element") Then
      Error.Raise("Invalid compare object")
      Return 0
    Endif
    If length = 0 Then
      length = If(src.Len() > $StorageLength, $StorageLength, src.Len())
    Endif
    Dest = src()
  Else
    If rdType = gb.pointer Then
      dest = src
    Else
      Dest = VarPtr(src)
      If rdType = gb.string Then
        length = src.len
      Else
        length = SizeOf(rdType)
      Endif
    Endif
  Endif

  If offset + length > $StorageLength Then
    Error.Raise("Out Of Bounds")
    Return 0
  Endif

  Dim result As Integer = memcmp($RootAddress + offset, Dest, length)
  Return result

End


Public Sub Equal(src As Variant, Optional length As Integer = 0, offset As Integer = 0) As Boolean

  Return If(VerifyCompare(src, length, offset) = 0, True, False)

End

Public Sub Less(src As Variant, Optional length As Integer = 0, offset As Integer = 0) As Boolean

  Dim result As Integer = If(VerifyCompare(src, length, offset) < 0, True, False)

  Return result

End

Public Sub Greater(src As Variant, Optional length As Integer = 0, offset As Integer = 0) As Boolean

  Dim result As Boolean = If(VerifyCompare(src, length, offset) > 0, True, False)

  Return result

End

Public Sub _VarLen() As Integer

  Return $StorageLength

End


Public Sub Len() As Integer

  Return $StorageLength

End


Public Sub _VarPtr() As Pointer

  Return $RootAddress

End

Public Sub _call() As Pointer

  Return $RootAddress

End

Public Sub _print()

  Dim MyStr As String = ""
  Dim MyByte As String

  Print "\nMemory listing for "; $SymbolName; " Length is "; $StorageLength; " Bytes"

  For i As Integer = 0 To $StorageLength - 1

    MyByte = Chr(Byte@($RootAddress + i))

    If i Mod 32 = 0 Then
      Print " - " & MyStr & "\n"; $RootAddress + i;;
      MyStr = ""
    Endif
    MyStr &= If(IsAlnum(MyByte) Or (mybyte = " ") Or IsPunct(mybyte), MyByte, ".")
    Print Hex$(Byte@($RootAddress + i), 2);;

  Next

  While i Mod 32 <> 0
    Inc i
    Print "   ";
  Wend

  Print " - " & MyStr & "\n"

End
