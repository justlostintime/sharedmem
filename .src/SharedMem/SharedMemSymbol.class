' Gambas class file

'Author Westwood JustLostintime
'Released Under:
'  GNU GENERAL Public LICENSE
'  Version 3, 29 June 2007
'  See project license file.
Export

'Fast Unsafe

Public SymName As String = ""
Public $oShm As Variant = Null

Public SpecialType As Integer = 0
Public SpecialObject As Variant
Public ParentRootAddress As Pointer = Null
Public LastMemorySync As String = "" ' this contains the file it was loaded from if it was loaded

Public ClassName As String = ""
Public SymType As Integer = -1
Public ObjectName As String = ""
Public ElementCount As Integer = -1 ' not an array
Public ElementType As Integer = 17

Public RootAddress As Pointer = Null   ' pointer to where the storage starts
Public DataAddress As Pointer = Null   ' Pointer to where the data is actually stored

Public ShmWait As Pointer = Null
Public ShmLastWriteTime As Pointer = Null

Public storageLength As Integer = 0       ' Length of the allocated block
Public dataLength As Integer = 0          ' Length of the data portion of the block

Public LastWriteLength As Integer = 0     ' Length of the last data written to the memory

Public Const StringBufferExtra As Integer = 1024      ' extra memory used when string is allocated so we dont have to reallocate to often

Public ZeroPointer As Pointer = Null
Public ZeroRef As Pointer = VarPtr(Zeropointer)
Public RootRef As Pointer = VarPtr(RootAddress)

Public UnsupportedList As String[] = ["File", "Stream"]

Property Value As Variant
Property Read LastWriteTime As Float
Property Read Length As Integer

Extern memcpy(dest As Pointer, src As Pointer, Len As Integer) As Integer In "libc:6"
' Extern rWrite(handle As Integer, buf As Pointer, cnt As Integer) As Integer In "libc:6" Exec "write"
' Extern rRead(handel As Integer, buf As Pointer, cnt As Integer) As Integer In "libc:6" Exec "read"
' Extern rClose(Handle As Integer) As Integer In "libc:6" Exec "close"

Public Sub _new(Optional vshm As Variant = Null)

  $oShm = vshm

End

'' Write the variable def  to the and format information to an output file
'' Optionally write the variables value as well
Public Sub _write(mFile As File, Optional WithData As Boolean = False)

  Write #Mfile, SymName As String
  Write #Mfile, SymType As Integer
  Write #Mfile, SpecialType As Integer
  Write #MFile, ClassName As String
  Write #MFile, ObjectName As String
  Write #MFile, ElementCount As Integer
  Write #MFile, ElementType As Integer
  Write #Mfile, RootAddress As Pointer
  Write #Mfile, DataAddress As Pointer
  Write #MFile, ShmWait As Pointer
  Write #MFile, storageLength As Integer
  Write #MFile, dataLength As Integer
  Write #MFile, LastWriteLength As Integer
  Write #Mfile, ShmLastWriteTime As Pointer

  If withData Then
    'Print "Saving ["; SharedMem.usermem[DataAddress]; "]"
    'Dim stbuffer As String
    'If symtype = gb.string Then stbuffer = SharedMem.UserMem[DataAddress]
    Flush #mfile
    SharedMem.UserMem.WriteData(DataAddress, mFile, DataLength, symtype)
  Endif

Catch
  Error.raise("_write symbol read error " & Error.text & " " & Error.where)
  Stop

End

'' This returns the total amount of space required to store the\
'' symbol to a file
Public Sub _serialize(Optional withData As Boolean = False) As Integer

  Dim mFile As File
  Dim rslt As Integer

  mfile = Open Null For Write
  _write(mfile, withData)
  rslt = Seek(mFile)
  Close mfile

  Return rslt

End

'' Read a variable def And control information From an Input file
'' Optionally load the data as well in to the shared memory
Public Sub _read(MFile As File, Optional WithData As Boolean = False)

  If WithData Then
    If Not IsNull(RootAddress) And WithData Then SharedMem.ShmFree(RootAddress)
    RootAddress = Null
  Endif

  SymName = Read #Mfile As String
  SymType = Read #Mfile As Integer
  SpecialType = Read #Mfile As Integer
  ClassName = Read #MFile As String
  ObjectName = Read #MFile As String
  ElementCount = Read #MFile As Integer
  ElementType = Read #MFile As Integer
  RootAddress = Read #Mfile As Pointer
  DataAddress = Read #Mfile As Pointer
  ShmWait = Read #Mfile As Pointer
  storageLength = Read #Mfile As Integer
  dataLength = Read #Mfile As Integer
  LastWriteLength = Read #Mfile As Integer
  ShmLastWriteTime = Read #Mfile As Pointer

  If WithData Then
    RootAddress = Null
    DataAddress = Null
    If (AllocStorage(datalength)) Then
      SharedMem.UserMem.ReadData(DataAddress, mFile, DataLength, symtype)
    Endif
  Endif

Catch
  Error.raise("_read symbol read error " & Error.text & ", Probably invalid symbol file format")
  Stop

End

Public Sub updateobjectinfo(data As Variant)

  If symtype = gb.object Then
    ClassName = Object.Class(data).name
    ObjectName = Object.type(data)
    If UnsupportedList.exist(ClassName) Then
      Error.Raise("SharedMem Unsupported data type :" & Classname)
    Endif
    If Object.Class(data).Symbols.Exist("Dim") Then
      SpecialType = SharedMem.ShmTypeAry
      ElementCount = data.length
      ElementType = data.type
    Endif
  Endif

End

Public Sub SetSymbol(Sname As String, data As Variant, Optional extrastorage As Integer = 0) As Boolean ' when null is entered then we are in loading mode

  If Not IsNull(Sname) Then

    SymName = Sname
    SymType = TypeOf(data)
    'Print "New variable(" & SymName & ") of type ", SymType
    storageLength = extrastorage

    If symtype = gb.object Then
      ClassName = Object.Class(data).name
      ObjectName = Object.type(data)
      If UnsupportedList.exist(ClassName) Then
        Error.Raise("SharedMem Unsupported data type :" & Classname)
        Return False
      Endif
      If Object.Class(data).Symbols.Exist("Dim") Then
        SpecialType = SharedMem.ShmTypeAry
        ElementCount = data.length
        ElementType = data.type
      Endif
    Endif

    SharedMem.Add(Me)

    ShmWrite(data)

  Endif

  Return True

Catch
  Error.Propagate()

End

Public Sub _wait() As Integer

  SetLastWrite()
  SharedMem.UserMem[ShmWait] += 1

End

Public Sub _waiting() As Boolean

  If SharedMem.UserMem[ShmWait] > 0 Then Return True
  Return False

End

Public Sub GetWaitCount() As Integer

  Return SharedMem.UserMem[ShmWait]

End

Public Sub _ClearWait() As Integer

  SharedMem.UserMem[ShmWait] -= 1

End

Public Sub getLastWrite() As Float

  If ShmLastWriteTime = Null Then
    Error.Raise("last write time pointer is nill" & SymName)
  Endif
  Return SharedMem.UserMem[ShmLastWriteTime, gb.float]

End

Public Sub SetLastWrite() As Float

  If ShmLastWriteTime = Null Then
    Error.Raise("last write time pointer is nill" & SymName)
  Endif

  Dim currentTime As Float = Now
  Dim Fracpart As Float = Frac(Timer)
  currenttime += FracPart
  SharedMem.UserMem[ShmLastWriteTime, gb.float] = currenttime

  Return currenttime

End

Public Sub SetStorage(data As Variant, Optional ExtraLen As Integer = 0) As Boolean

  DataLength = SharedMem.Usermem._SizeOf(data)
  Return AllocStorage(extraLen + DataLength)

Catch
  'Error.Raise("SetStorage set error", Error.text, Error.where)
  Error.Propagate()
  Stop

End

Public Sub AllocStorage(iLength As Integer) As Boolean

  Dim NewStorageLength As Integer
  Dim NewStorage As Pointer

  NewStorageLength = SharedMem.AllocHeaderLen + ilength
  DataLength = iLength

  If Not IsNull(RootAddress) Then       ' free and reallocate storage

    If NewStorageLength > StorageLength Then
      StorageLength = NewStorageLength

      If symtype = gb.string Or symtype = gb.object Then
        If gb.string Then
          StorageLength += StringBufferExtra
        Endif
        SharedMem.ShmFree(SharedMem.UserMem[DataAddress + 1, gb.pointer, True])
        newStorage = SharedMem.ShmAlloc(storageLength + 1)
        SharedMem.UserMem[DataAddress + 1, gb.pointer, True] = newstorage
        SharedMem.UserMem.SetType(DataAddress, symtype)
        SharedMem.UserMem.SetType(newStorage + SharedMem.DataOffset, symtype)     ' make sure the indexed storage also defines the type of data
      Else
        SharedMem.ShmFree(RootAddress)
        RootAddress = SharedMem.ShmAlloc(storageLength + 1)
        DataAddress = RootAddress + SharedMem.DataOffset
        ShmWait = RootAddress + SharedMem.WaitOffset
        ShmLastWriteTime = RootAddress + SharedMem.LastWriteOffset
        SharedMem.UserMem.SetType(DataAddress, symtype)
        SharedMem.UserMem[ShmLastWriteTime] = Now + Frac(Timer)
        SharedMem.UserMem[shmWait] = CLong(0)
      Endif
    Endif
  Else
    StorageLength = NewStorageLength
    If symtype = gb.string Or symtype = gb.object Then
      RootAddress = SharedMem.ShmAlloc(SizeOf(gb.pointer) + 1 + SharedMem.AllocHeaderLen)
      DataAddress = RootAddress + SharedMem.AllocHeaderLen
      newStorage = SharedMem.ShmAlloc(storageLength + 1)
      SharedMem.UserMem[DataAddress + 1, gb.pointer, True] = newstorage
      SharedMem.UserMem.SetType(DataAddress, symtype)
      SharedMem.UserMem.SetType(NewStorage + SharedMem.dataoffset, symtype)
    Else
      RootAddress = SharedMem.ShmAlloc(storageLength + 1)
      DataAddress = RootAddress + SharedMem.AllocHeaderLen
      SharedMem.UserMem.Settype(DataAddress, symtype)
    Endif
    ShmWait = RootAddress + SharedMem.WaitOffset
    ShmLastWriteTime = RootAddress + SharedMem.LastWriteOffset

    SharedMem.UserMem[ShmLastWriteTime] = Now + Frac(Timer)
    SharedMem.UserMem[shmwait] = CLong(0)

  Endif

  If Not IsNull(RootAddress) Then
    Return True
  Else
    Return False
  Endif

Catch
  Dim emsg As String = "AllocStorage set error : " & Error.text & "-" & Error.where
  Error.Raise(emsg)
  Stop

End

Public Sub Serialize(data As Variant)

  datalength = mem._SizeOf(data)

Catch
  Error.Raise("Serialize :" & Error.text & " " & Error.where)
  Stop

End

Public Sub ShmRead() As Variant

  Return SharedMem.UserMem[DataAddress, SymType]

Catch
  Error.Propagate()

End

Public Sub ShmReadSub(...) As Variant

  If SpecialType = 1 Then
    If param.count > 0
      If Not ((ElementType = gb.object) Or (ElementType = gb.string))
        Dim ElementAddress As Pointer = ShmElementAddress(Param[0])
        Return SharedMem.UserMem[ElementAddress, ElementType, True]
      Else
        Select Case ElementType
          Case gb.String, gb.object
            Dim MyValue As Variant = ShmRead()
            Return MyValue[Param[0]]
        End Select
        Error.Raise("Unsupported data type for subscript " & SymName)
      Endif
    Else
      Error.Raise("SubScript out of range for" & Quote(SymName) & "[MAX=" & Str(ElementCount - 1) & "]")
    Endif
  Else If SpecialType = 0 Then
    Dim MyObjectSingle As Variant = ShmRead()
    Return MyObjectSingle[Param[0]]
  Else
    Error.Raise("Unsupported array type in " & SymName)
  Endif

End

Public Sub ShmWrite(mdata As Variant) As Integer

  If TypeOf(mdata) <> SymType   ' this is done to prevent the need to save and reload table while other task may be using this variable
    Error.Raise("ShmWrite: Can not change memory storage type after creation when Notify requested from " & SharedMem.DataTypes[SymType] & " to " & SharedMem.DataTypes[TypeOf(mdata)])
    Return 0
  Endif

  If IsNull(RootAddress) Or SymType = gb.object Or symtype = gb.string Then

    If Not SetStorage(mdata) Then
      Error.Raise("ShmWrite : Unable to allocate required storage")
      Return 0
    Endif

    'Print " Set storage done and about to store the data "
    SharedMem.UserMem[DataAddress] = mdata
    'Print " Set done"
    LastWriteLength = SharedMem.UserMem.LastWriteLength

  Else
    SharedMem.UserMem[DataAddress, symtype] = mdata
  Endif

  Return LastWriteLength
  'Print "ShmWrite done"

Catch
  Error.Propagate()

End

Public Sub ShmWriteSub(data As Variant, ...)

  If SpecialType = 1 Then
    If Param.count > 0                ' we have some subscripts
      'If ElementType = TypeOf(data)
      If Not ((ElementType = gb.object) Or (ElementType = gb.string)) Then
        SharedMem.UserMem[ShmElementAddress(Param[0]), ElementType, True] = data
      Else
        Select Case ElementType
          Case gb.String, gb.Object
            Dim MyValue As Variant = ShmRead()
            MyValue[Param[0]] = data
            ShmWrite(MyValue)
            ElementCount = MyValue.Count
            Return
        End Select
        Error.Raise("Unsupported data type for subscript in " & SymName)
      Endif
      'Else
      ' Error.Raise("Element Data type mismatch " & SymName)
      'Endif
    Else
      Error.Raise("SubScript out of range  for " & Quote(SymName) & "[MAX=" & Str(ElementCount - 1) & "]")
    Endif
  Else If specialtype = 0 Then
    Dim MyObjectSingle As Variant = ShmRead()
    MyObjectSingle[Param[0]] = data
    ShmWrite(MyObjectSingle)
    ElementCount = MyObjectSingle.Count
  Else
    Error.Raise("Unsupported array type in " & SymName)
  Endif

End

' This calculates the offset/Virtual Address from the beginning of the array
' The the element we are processing is located, Updated for Gambas 3.18

Public Sub ShmElementAddress(index As Integer) As Pointer

  Dim bLen As Byte
  Dim inSave As Integer = 0
  Dim offset As Integer = 0
  Dim RealLoc As Pointer = DataPtr()

  ' Bypass calculation for objects stored with a write object instruction 3.18 version
  blen = Byte@(RealLoc + 1)        ' Get the length of the object name
  inSave = CInt(blen) + 2 + 1      ' Add the length of the name header and first byte of array info
  RealLoc += inSave                ' bypass the object write information stored in memory
  'bLen = Byte@(SharedMem.UserMem[RootAddress + offset])
  ' Get the byte which identifies how many elements in array
  ' SharedMem.UserMem.DumpMem(RealLoc, 200, "PointToArray.mem")

  blen = Byte@(RealLoc)                                   ' Read the array element count value

  offset = If(BTst(bLen, 7), If(BTst(bLen, 6), 4, 2), 1)  ' skip the element count
  offset += SizeOf(ElementType) * index
  'For testing make sure we point To the correct entry
  'RealLoc += offset

  Return DataOffsetPtr() + offset + inSave

End

Public Sub ShmCopy(mempointer As Pointer, memlen As Integer)

  DataLength = memlen - SharedMem.AllocHeaderLen

  If Not IsNull(RootAddress) Then

    If memLen > StorageLength Then
      SharedMem.ShmFree(RootAddress)
      StorageLength = memlen
      RootAddress = SharedMem.ShmAlloc(storageLength)
      DataAddress = RootAddress + SharedMem.DataOffset
      ShmWait = RootAddress + SharedMem.WaitOffset
      ShmLastWriteTime = RootAddress + SharedMem.LastWriteOffset
    Endif

    memcpy(RootAddress, mempointer, memlen)
  Else
    StorageLength = memlen
    RootAddress = SharedMem.ShmAlloc(storageLength)
    DataAddress = RootAddress + SharedMem.DataOffset
    ShmWait = RootAddress + SharedMem.WaitOffset
    ShmLastWriteTime = RootAddress + SharedMem.LastWriteOffset
    ZeroRef = VarPtr(Zeropointer)
    RootRef = VarPtr(RootAddress)
    memcpy(RootAddress, mempointer, memlen)
  Endif

End

Public Sub _call(Optional value As Variant) As Variant

  If Param.count > 0 Then
    ShmWrite(value)
    Return value
  Else
    Return ShmRead()
  Endif

End

Public Sub _get(...) As Variant

  If Param.count = 0 Then
    Return ShmRead()
  Else
    Return ShmReadSub(Param[0])
  Endif

End

Public Sub _put(value As Variant, index As Integer)

  ShmWriteSub(Value, index)

End

Public Sub memSize() As Integer

  Return storageLength

End

Public Sub SizeOf() As Integer

  Return DataLength

End

Public Sub SetZeros()

  ZeroRef = VarPtr(Zeropointer)
  RootRef = VarPtr(RootAddress)

End

Public Sub DataOffsetPtr() As Pointer

  Return SharedMem.UserMem.DataOffset(DataAddress, SymType)

End

''Returns the real address of the variable header, ie containing the
'' basic information And pointer To storage For strings, And objects
Public Sub AddressPtr() As Pointer

  Return SharedMem.UserMem.AddrReal(RootAddress)

End

''Returns the real address of the data storage of the
'' object or string or base data types
Public Sub DataPtr() As Pointer

  Return SharedMem.UserMem.AddrData(DataAddress, SymType)

End

'' Dumps the variables value to an output file
Public Sub DumpMem()

  Dim Src As Pointer = DataPtr()

  mem.DumpMem(Src, DataLength, User.home &/ "Desktop/" &/ SymName & ".dump")

End

'' Prints the details of this variable to the current output sink
Public Sub _print()

  Print "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  Print "Symbol Name: "; Me.SymName, "SymType: "; SharedMem.DataTypes[Me.SymType]
  Print "Special Type:", If(Me.SpecialType = 1, "Yes", "No"), "Class("; Me.ClassName; ")", "ObjectName("; Me.ObjectName; ")"
  Print "Address:"; CLong(Me.RootAddress); "/"; CLong(Me.DataAddress); "/";
  Print If(Me.SymType = gb.string Or Symtype = gb.object, CLong(SharedMem.usermem[DataAddress + 1, gb.pointer, True]), " - "),
    Print "Length:"; Me.dataLength, "Storage len: "; Me.storageLength
  Print "Last Write length : "; LastWriteLength, "ElementCount :"; ElementCount, "ElementType : "; SharedMem.DataTypes[ElementType]
  Print "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"

End

Private Function Value_Read() As Variant

  Return ShmRead()

End

Private Sub Value_Write(vValue As Variant)

  ShmWrite(vValue)

End

Private Function LastWriteTime_Read() As Float

  Dim ltime As Float = getLastWrite()

  Return ltime

End

Private Function Length_Read() As Integer

  Dim blklen As Integer = 0

  blklen += SymName.len + 1
  blklen += SizeOf(gb.integer) + 1   ' SymType As Integer
  blklen += SizeOf(gb.integer) + 1  ' SpecialType As Integer
  blklen += ClassName.Len + 1
  blklen += ObjectName.Len + 1
  blklen += SizeOf(gb.integer) + 1   'ElementCount As Integer
  blklen += SizeOf(gb.integer) + 1  'ElementType As Integer
  blklen += SizeOf(gb.pointer) + 1  'RootAddress As Pointer
  blklen += SizeOf(gb.pointer) + 1  'ataAddress As Pointer
  blklen += SizeOf(gb.pointer) + 1  'ShmWait As Pointer
  blklen += SizeOf(gb.integer) + 1  'storageLength As Integer
  blklen += SizeOf(gb.integer) + 1  'dataLength As Integer
  blklen += SizeOf(gb.integer) + 1  'LastWriteLength As Integer
  blklen += SizeOf(gb.pointer) + 1 'ShmLastWriteTime As Pointer

  Return blklen

End
