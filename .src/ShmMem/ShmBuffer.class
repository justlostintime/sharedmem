' Gambas class file

$Fields As Collection
Dimensions As Long[]
BlockSizes As Long[]
MySharedMem As ShmMem
InsideVar As Boolean = False

Static Public cShmBuffer As Integer = 28                        '' The Constant identifying this class name must not be a valid datatype integer
Static Public cShmBufferEntry As Integer = 29             '' The entry in a Buffer Element index object type

Property Read Data As Pointer Use $Data                     '' Return the real address data portion of the Buffer
Property Read Length As Long Use $Length                 '' The Length of the Data Portion of the buffer
Property Read Count As Long                                            '' Returns the length of data portion of the  buffer in bytes
Property Read Fields As Collection                                   '' Returns the collection of fields elements in the buffer
Property Read Dim As Long                                                 '' count of specified dimentions  count, uses pointer to be unsigned
Property Read Bounds As Long[]                                  '' return an array containg the bounds for the array, length Dim elements

Public SetHeadType As Integer = cShmBuffer               '' The Buffer  header Class
Public SetEntryType As Integer = cShmBufferEntry    '' The Buffer Entry Class


Static Public Sub _init()

  ShmVarStorage.DefineClass("ShmBuffer", cShmBuffer)
  ShmVarStorage.DefineClass("ShmBufferElement", cShmBufferEntry)

End

'' Pass in the Shared memory object where the buffer will be allocated
'' Then pass in the Length of the buffer required, if not specified then it will
'' be the sum of all fields allocated, which must be specified when the, buffer is created.
'' Then any number of array subscripts may be specified 0..n eg [1,4,78,2]
'' Example a = new ShmBuffer(MyShm,2000,[2,100]) creates a buffer with 2x100 entries of 2000 bytes
''                   a = new ShmBuffer(MyShm,[ ["Entry1":sizeof[gb.integer] , ["entry2":Sizeof(gb.Long)] ],[2000]) creates a buffer with two fields in an array of 2000 entries of that structure
''                   a = new ShmBuffer(MyShm,1000000)  creates a buffer of 1meg
Public Sub _new(Shm As ShmMem, ElementLengthDef As Variant, Optional ArrayDef As Long[] = [1])

  $Fields = New Collection(gb.IgnoreCase)
  $Fields.Default = 0
  MySharedMem = Shm

  Dimensions = New Long[ArrayDef.Count + 1]
  BlockSizes = New Long[Dimensions.count + 1]

  BlockSizes[BlockSizes.max] = 1

  If TypeOf(ElementLengthDef) = gb.object Then                                                  ' if object then assume it is a collection of fields
    Dimensions[Dimensions.max] = Define(ElementLengthDef)                         ' return the total length of the field list
  Else
    Dimensions[Dimensions.max] = ElementLengthDef
  Endif

  $Length = 0
  For p As Long = Dimensions.max DownTo 0
    BlockSizes[p] = Dimensions[p] * BlockSizes[p + 1]
  Next

  $Length = BlockSizes[0]

  Dim j As Long = 0
  For Each i As Long In ArrayDef
    Dimensions[j] = i
    Inc j
  Next

  Try $Data = MySharedMem.Alloc($Length)
  If Error Then
    Error.Raise("Buffer Allocation Error :" & Error.text)
  Endif

End

Public Sub _free()

  MySharedMem = Null

  If $Fields.count > 0 Then
    For Each t As ShmBufferField In $fields
      $Fields.remove(t.name)
    Next
  Endif

End


Sub GetOffset(Dims As Variant) As Pointer       '' calculate the offset based upon array structure

  Dim i As Long = 0

  If Dims.count > Dimensions.max Then
    Error.Raise("ShmBuffer Error : Invalid number of Dimensions")
  Endif

  Dim location As Pointer

  For i = 0 To Param.Max
    location += Dims[i] * BlockSizes[i]
  Next

  Return location

End


Public Sub _property(...) As Boolean

  Return $Fields.Exist(Param.name)

End

Public Sub _unknown(...) As Variant

  Dim el As ShmBufferField

  el = $Fields[Param.name]

  If Param.count = 0 Then

  Else

  Endif

End

Public Sub {Define}(Element As String, ElementLength As Integer, ...)                                '' define the element must provide the offset for root array element

  Dim el As New ShmBufferField(Me, Element, GetOffset(Param.all), ElementLength)

  $fields[Element] = el

End


Public Sub _put(Value As Variant, ...)                        '' Indexes are always in the form of bytes/field elements if more that one dimension



End

Public Sub _get(...) As Variant



End

Private Function Count_Read() As Long

  Return $Length

End

Private Function Fields_Read() As Collection

  Return $Fields

End

Private Function Dim_Read() As Long

  Return Dimensions.count

End

Private Function Bounds_Read() As Long[]

  Return Dimensions.Copy()

End
